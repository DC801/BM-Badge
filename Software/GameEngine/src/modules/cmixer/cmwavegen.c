#include "cmwavegen.h"
#include <stdlib.h>

typedef struct
{
	uint32_t sampledelta;
	uint32_t sample;
} SawtoothUData;

typedef struct
{
	uint32_t indexdelta;
	uint32_t index;
} SineUData;

/*
 * When implementing the handlers, the samples are cm_Int16
 * and the channels are stereo. The length describes number
 * of cm_Int16 in buffer rather than number of bytes.
 *
 * You can look at wav_handler in cmixer.c to see an example
 */
static void sawtooth_handler(cm_Event *e)
{
	SawtoothUData *sawtooth = (SawtoothUData *)e->udata;
	switch (e->type)
	{
		case CM_EVENT_DESTROY:
			free(sawtooth);
			break;
		case CM_EVENT_SAMPLES:
		{
			// Put variables in locals to reduce aliasing
			int buflen = e->length & ~1;
			cm_Int16 *buffer = e->buffer;
			uint32_t sample = sawtooth->sample;
			uint32_t sampledelta = sawtooth->sampledelta;
			for (int i = 0; i < buflen; i += 2)
			{
				buffer[i] = sample;
				buffer[i + 1] = sample;
				sample += sampledelta;
			}
			sawtooth->sample = sample;
			break;
		}
		case CM_EVENT_REWIND:
			sawtooth->sample = 0;
			break;
	}
}

#define SINE_INTDIGITS	9
#define SINE_FRACDIGITS	(sizeof(uint32_t) * 8 - SINE_INTDIGITS)
static void sine_handler(cm_Event *e)
{
	// Big, disgusting sine table generated with tools/sinetable.py
	static const cm_Int16 sinevalues[1 << SINE_INTDIGITS] = {
		0x0,0x192,0x324,0x4b6,0x647,0x7d9,0x96a,0xafb,0xc8b,0xe1b,0xfab,0x1139,0x12c7,0x1455,0x15e1,0x176d,
		0x18f8,0x1a82,0x1c0b,0x1d93,0x1f19,0x209f,0x2223,0x23a6,0x2527,0x26a7,0x2826,0x29a3,0x2b1e,0x2c98,0x2e10,0x2f86,
		0x30fb,0x326d,0x33de,0x354d,0x36b9,0x3824,0x398c,0x3af2,0x3c56,0x3db7,0x3f16,0x4073,0x41cd,0x4325,0x447a,0x45cc,
		0x471c,0x4869,0x49b3,0x4afa,0x4c3f,0x4d80,0x4ebf,0x4ffa,0x5133,0x5268,0x539a,0x54c9,0x55f4,0x571d,0x5842,0x5963,
		0x5a81,0x5b9c,0x5cb3,0x5dc6,0x5ed6,0x5fe2,0x60eb,0x61f0,0x62f1,0x63ee,0x64e7,0x65dd,0x66ce,0x67bc,0x68a5,0x698b,
		0x6a6c,0x6b4a,0x6c23,0x6cf8,0x6dc9,0x6e95,0x6f5e,0x7022,0x70e1,0x719d,0x7254,0x7306,0x73b5,0x745e,0x7503,0x75a4,
		0x7640,0x76d8,0x776b,0x77f9,0x7883,0x7908,0x7989,0x7a04,0x7a7c,0x7aee,0x7b5c,0x7bc4,0x7c29,0x7c88,0x7ce2,0x7d38,
		0x7d89,0x7dd5,0x7e1c,0x7e5e,0x7e9c,0x7ed4,0x7f08,0x7f37,0x7f61,0x7f86,0x7fa6,0x7fc1,0x7fd7,0x7fe8,0x7ff5,0x7ffc,
		0x7fff,0x7ffc,0x7ff5,0x7fe8,0x7fd7,0x7fc1,0x7fa6,0x7f86,0x7f61,0x7f37,0x7f08,0x7ed4,0x7e9c,0x7e5e,0x7e1c,0x7dd5,
		0x7d89,0x7d38,0x7ce2,0x7c88,0x7c29,0x7bc4,0x7b5c,0x7aee,0x7a7c,0x7a04,0x7989,0x7908,0x7883,0x77f9,0x776b,0x76d8,
		0x7640,0x75a4,0x7503,0x745e,0x73b5,0x7306,0x7254,0x719d,0x70e1,0x7022,0x6f5e,0x6e95,0x6dc9,0x6cf8,0x6c23,0x6b4a,
		0x6a6c,0x698b,0x68a5,0x67bc,0x66ce,0x65dd,0x64e7,0x63ee,0x62f1,0x61f0,0x60eb,0x5fe2,0x5ed6,0x5dc6,0x5cb3,0x5b9c,
		0x5a81,0x5963,0x5842,0x571d,0x55f4,0x54c9,0x539a,0x5268,0x5133,0x4ffa,0x4ebf,0x4d80,0x4c3f,0x4afa,0x49b3,0x4869,
		0x471c,0x45cc,0x447a,0x4325,0x41cd,0x4073,0x3f16,0x3db7,0x3c56,0x3af2,0x398c,0x3824,0x36b9,0x354d,0x33de,0x326d,
		0x30fb,0x2f86,0x2e10,0x2c98,0x2b1e,0x29a3,0x2826,0x26a7,0x2527,0x23a6,0x2223,0x209f,0x1f19,0x1d93,0x1c0b,0x1a82,
		0x18f8,0x176d,0x15e1,0x1455,0x12c7,0x1139,0xfab,0xe1b,0xc8b,0xafb,0x96a,0x7d9,0x647,0x4b6,0x324,0x192,
		0x0,-0x192,-0x324,-0x4b6,-0x647,-0x7d9,-0x96a,-0xafb,-0xc8b,-0xe1b,-0xfab,-0x1139,-0x12c7,-0x1455,-0x15e1,-0x176d,
		-0x18f8,-0x1a82,-0x1c0b,-0x1d93,-0x1f19,-0x209f,-0x2223,-0x23a6,-0x2527,-0x26a7,-0x2826,-0x29a3,-0x2b1e,-0x2c98,-0x2e10,-0x2f86,
		-0x30fb,-0x326d,-0x33de,-0x354d,-0x36b9,-0x3824,-0x398c,-0x3af2,-0x3c56,-0x3db7,-0x3f16,-0x4073,-0x41cd,-0x4325,-0x447a,-0x45cc,
		-0x471c,-0x4869,-0x49b3,-0x4afa,-0x4c3f,-0x4d80,-0x4ebf,-0x4ffa,-0x5133,-0x5268,-0x539a,-0x54c9,-0x55f4,-0x571d,-0x5842,-0x5963,
		-0x5a81,-0x5b9c,-0x5cb3,-0x5dc6,-0x5ed6,-0x5fe2,-0x60eb,-0x61f0,-0x62f1,-0x63ee,-0x64e7,-0x65dd,-0x66ce,-0x67bc,-0x68a5,-0x698b,
		-0x6a6c,-0x6b4a,-0x6c23,-0x6cf8,-0x6dc9,-0x6e95,-0x6f5e,-0x7022,-0x70e1,-0x719d,-0x7254,-0x7306,-0x73b5,-0x745e,-0x7503,-0x75a4,
		-0x7640,-0x76d8,-0x776b,-0x77f9,-0x7883,-0x7908,-0x7989,-0x7a04,-0x7a7c,-0x7aee,-0x7b5c,-0x7bc4,-0x7c29,-0x7c88,-0x7ce2,-0x7d38,
		-0x7d89,-0x7dd5,-0x7e1c,-0x7e5e,-0x7e9c,-0x7ed4,-0x7f08,-0x7f37,-0x7f61,-0x7f86,-0x7fa6,-0x7fc1,-0x7fd7,-0x7fe8,-0x7ff5,-0x7ffc,
		-0x7fff,-0x7ffc,-0x7ff5,-0x7fe8,-0x7fd7,-0x7fc1,-0x7fa6,-0x7f86,-0x7f61,-0x7f37,-0x7f08,-0x7ed4,-0x7e9c,-0x7e5e,-0x7e1c,-0x7dd5,
		-0x7d89,-0x7d38,-0x7ce2,-0x7c88,-0x7c29,-0x7bc4,-0x7b5c,-0x7aee,-0x7a7c,-0x7a04,-0x7989,-0x7908,-0x7883,-0x77f9,-0x776b,-0x76d8,
		-0x7640,-0x75a4,-0x7503,-0x745e,-0x73b5,-0x7306,-0x7254,-0x719d,-0x70e1,-0x7022,-0x6f5e,-0x6e95,-0x6dc9,-0x6cf8,-0x6c23,-0x6b4a,
		-0x6a6c,-0x698b,-0x68a5,-0x67bc,-0x66ce,-0x65dd,-0x64e7,-0x63ee,-0x62f1,-0x61f0,-0x60eb,-0x5fe2,-0x5ed6,-0x5dc6,-0x5cb3,-0x5b9c,
		-0x5a81,-0x5963,-0x5842,-0x571d,-0x55f4,-0x54c9,-0x539a,-0x5268,-0x5133,-0x4ffa,-0x4ebf,-0x4d80,-0x4c3f,-0x4afa,-0x49b3,-0x4869,
		-0x471c,-0x45cc,-0x447a,-0x4325,-0x41cd,-0x4073,-0x3f16,-0x3db7,-0x3c56,-0x3af2,-0x398c,-0x3824,-0x36b9,-0x354d,-0x33de,-0x326d,
		-0x30fb,-0x2f86,-0x2e10,-0x2c98,-0x2b1e,-0x29a3,-0x2826,-0x26a7,-0x2527,-0x23a6,-0x2223,-0x209f,-0x1f19,-0x1d93,-0x1c0b,-0x1a82,
		-0x18f8,-0x176d,-0x15e1,-0x1455,-0x12c7,-0x1139,-0xfab,-0xe1b,-0xc8b,-0xafb,-0x96a,-0x7d9,-0x647,-0x4b6,-0x324,-0x192,
	};
	SineUData *sine = (SineUData *)e->udata;
	switch (e->type)
	{
		case CM_EVENT_DESTROY:
			free(sine);
			break;
		case CM_EVENT_SAMPLES:
		{
			// Put variables in locals to reduce aliasing
			int buflen = e->length & ~1;
			cm_Int16 *buffer = e->buffer;
			uint32_t index = sine->index;
			uint32_t indexdelta = sine->indexdelta;
			for (int i = 0; i < buflen; i += 2)
			{
				cm_Int16 sample = sinevalues[index >> SINE_FRACDIGITS];
				buffer[i] = sample;
				buffer[i + 1] = sample;
				index += indexdelta;
			}
			sine->index = index;
			break;
		}
		case CM_EVENT_REWIND:
			sine->index = 0;
			break;
	}
}

static void cm_init_info_from_common(cm_SourceInfo *info, cm_WaveGenCommon *wavegen)
{
	info->samplerate = wavegen->samplerate;
	info->length = info->samplerate * wavegen->duration;
}

cm_Source *cm_new_sawtooth(cm_WaveGenSawtooth *sawtooth)
{
	cm_SourceInfo info;
	SawtoothUData *udata = (SawtoothUData *)malloc(sizeof(SawtoothUData));
	info.udata = udata;
	if (udata == NULL)
	{
		return NULL;
	}
	cm_init_info_from_common(&info, &sawtooth->common);
	info.handler = sawtooth_handler;
	float ratio = (float)sawtooth->common.frequency / info.samplerate;
	udata->sampledelta = (uint32_t)(ratio * (1 << 16));
	udata->sample = 0;
	cm_Source *src = cm_new_source(&info);
	if (src == NULL)
	{
		free(udata);
	}
	return src;
}

cm_Source *cm_new_sine(cm_WaveGenSine *sine)
{
	cm_SourceInfo info;
	SineUData *udata = (SineUData *)malloc(sizeof(SineUData));
	info.udata = udata;
	if (udata == NULL)
	{
		return NULL;
	}
	cm_init_info_from_common(&info, &sine->common);
	info.handler = sine_handler;
	float ratio = (float)sine->common.frequency / info.samplerate;
	udata->indexdelta = (uint32_t)(ratio * UINT32_MAX);
	udata->index = 0;
	cm_Source *src = cm_new_source(&info);
	if (src == NULL)
	{
		free(udata);
	}
	return src;
}
