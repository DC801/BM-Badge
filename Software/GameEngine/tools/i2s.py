#!/usr/bin/env python3

# Tool to generate NRF I2S and NAU8810 PLL params
# when given a frequency by the user
from typing import Optional

NRF_I2S_MCK_MHZ_32MDIV = [
        # Higher clocks exist for future nRF52 models,
        # but they are not present on the nRF52840 :(
        8,
        10,
        11,
        15,
        16,
        21,
        23,
        30,
        31,
        32,
        42,
        63,
        125,
]

NRF_I2S_RATIOS = [
        # 32, 48, and 64 also exist, but their ratios
        # are impossible to use with the NAU8810 even
        # with PLL due to the constraint IMCLK = 256 * LRCK.
        96,
        128,
        192,
        256,
        384,
        512,
]

NAU8810_MCLKSEL_RATIOS = [
        1,
        1.5,
        2,
        3,
        4,
        6,
        8,
        12,
]

PLL_N_MAX = 13
PLL_N_MIN = 5

HEADER_FORMAT = '''
#ifndef DRV_NAU8810_I2S_PARAMS_H
#define DRV_NAU8810_I2S_PARAMS_H

///////////////////////////////////////////////////////////////////////
//////////////// Header file generated by tools/i2s.py //////////////// 
///////////////////////////////////////////////////////////////////////

#define DRV_NAU8810_MCK NRF_I2S_MCK_32MDIV{0}
#define DRV_NAU8810_RATIO NRF_I2S_RATIO_{1}X
#define DRV_NAU8810_PLLN {2}
#define DRV_NAU8810_PLLK1 {3}
#define DRV_NAU8810_PLLK2 {4}
#define DRV_NAU8810_PLLK3 {5}
#define DRV_NAU8810_MCLKSEL {6}
#define DRV_NAU8810_PLLM {7}
#define DRV_NAU8810_LRCK {8}

#endif
'''

def get_i2s_params(rate: float, ratio: Optional[int]) -> (float, float, float):
    rate_mhz = float(rate) / 1000
    best_error = float('inf')
    best_rate, best_mdiv, best_ratio = 0, 0, 0
    ratios = NRF_I2S_RATIOS
    if ratio != None:
        if ratio not in ratios:
            raise ValueError('NRF I2S ratio impossible to use with NAU8810 PLL')
        ratios = [int(ratio)]
    for mdiv in NRF_I2S_MCK_MHZ_32MDIV:
        for ratio in ratios:
            curr_rate = 32 / mdiv / ratio
            curr_error = abs(rate_mhz - curr_rate) / rate_mhz
            if curr_error < best_error:
                best_mdiv = mdiv
                best_ratio = ratio
                best_rate = curr_rate
                best_error = curr_error
    return best_rate * 1000, best_mdiv, best_ratio

# NAU8810 PLL params can be derived solely from the ratio
# IMCLK / LRCK = 256, MCK / LRCK = ratio, so IMCLK = MCK * (256 / ratio)
def get_nau8810_pll_params(ratio: float) -> (int, int, int, int):
    import math
    f1 = 1
    f2 = (1024 / float(ratio))
    R = f2 / f1

    # Increasing mclksel ratio is preferred because
    # it puts f2 closer to the optimal range since
    # it'll always be too low (unfortunately...)
    for i,mclksel_ratio in enumerate(NAU8810_MCLKSEL_RATIOS):
        R = (f2 * mclksel_ratio) / f1
        if R >= PLL_N_MAX + 1:
            break
    if i == 0:
        raise ValueError('MCLK Ratio is too small to use with PLL')
    MCLKSEL = i - 1
    f2 *= NAU8810_MCLKSEL_RATIOS[MCLKSEL]

    PLLM = 0
    if R < PLL_N_MIN:
        PLLM = 1
        f1 *= 2
    R = f2 / f1
    if R < PLL_N_MIN:
        raise ValueError('MCLK Ratio is too big to use with PLL')

    # Derive rest of NAU8810 params
    pll_ratio, PLLN = math.modf(R)
    return int(PLLN), int(pll_ratio * (1 << 24)), MCLKSEL, PLLM

def main():
    import argparse
    parser = argparse.ArgumentParser(
        description='Derive best NRF I2S and NAU8810 PLL params for a given sample rate in kHz')
    parser.add_argument('--ratio', required=False, type=int, help='Force use of this ratio (i.e. 256)')
    parser.add_argument('rate', type=float)
    args = parser.parse_args()
    closest, mdiv, ratio = get_i2s_params(args.rate, args.ratio)
    PLLN, PLLK, MCLKSEL, PLLM = get_nau8810_pll_params(ratio)
    print(HEADER_FORMAT.format(
        mdiv,
        ratio,
        PLLN,
        (PLLK >> 18) & 0x1ff,
        (PLLK >> 9) & 0x1ff,
        PLLK & 0x1ff,
        MCLKSEL,
        PLLM,
        int(closest * 1000)).strip())

if __name__ == '__main__':
    main()
