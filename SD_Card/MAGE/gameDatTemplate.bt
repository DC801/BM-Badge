//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: gameDateTemplate.bt
//   Authors: Tawnos
//   Version: 1.0
//   Purpose: Parsing DC801's BM-Badge game.dat
//  Category: Game
// File Mask: game.dat
//  ID Bytes: 4D41474547414D45 //MAGEGAME
//   History: 
//------------------------------------------------


enum <uchar> primary_id_type{
    tileset_id,
    animation_id,
    entity_type_id,
};

enum <uchar> direction_type{
    north,
    east,
    south,
    west
};

enum <uchar> action_type{
    null_action,
    check_entity_name,
    check_entity_x,
    check_entity_y,
    check_entity_interact_script,
    check_entity_tick_script,
    check_entity_type,
    check_entity_primary_id,
    check_entity_secondary_id,
    check_entity_primary_id_type,
    check_entity_current_animation,
    check_entity_current_frame,
    check_entity_direction,
    check_entity_glitched,
    check_entity_hackable_state_a,
    check_entity_hackable_state_b,
    check_entity_hackable_state_c,
    check_entity_hackable_state_d,
    check_entity_hackable_state_a_u2,
    check_entity_hackable_state_c_u2,
    check_entity_hackable_state_a_u4,
    check_entity_path,
    check_save_flag,
    check_if_entity_is_in_geometry,
    check_for_button_press,
    check_for_button_state,
    check_warp_state,
    run_script,
    blocking_delay,
    non_blocking_delay,
    set_entity_name,
    set_entity_x,
    set_entity_y,
    set_entity_interact_script,
    set_entity_tick_script,
    set_entity_type,
    set_entity_primary_id,
    set_entity_secondary_id,
    set_entity_primary_id_type,
    set_entity_current_animation,
    set_entity_current_frame,
    set_entity_direction,
    set_entity_direction_relative,
    set_entity_direction_target_entity,
    set_entity_direction_target_geometry,
    set_entity_glitched,
    set_entity_hackable_state_a,
    set_entity_hackable_state_b,
    set_entity_hackable_state_c,
    set_entity_hackable_state_d,
    set_entity_hackable_state_a_u2,
    set_entity_hackable_state_c_u2,
    set_entity_hackable_state_a_u4,
    set_entity_path,
    set_save_flag,
    set_player_control,
    set_map_tick_script,
    set_hex_cursor_location,
    set_warp_state,
    set_hex_editor_state,
    set_hex_editor_dialog_mode,
    set_hex_editor_control,
    set_hex_editor_control_clipboard,
    load_map,
    show_dialog,
    play_entity_animation,
    teleport_entity_to_geometry,
    walk_entity_to_geometry,
    walk_entity_along_geometry,
    loop_entity_along_geometry,
    set_camera_to_follow_entity,
    teleport_camera_to_geometry,
    pan_camera_to_entity,
    pan_camera_to_geometry,
    pan_camera_along_geometry,
    loop_camera_along_geometry,
    set_screen_shake,
    screen_fade_out,
    screen_fade_in,
    mutate_variable,
    mutate_variables,
    copy_variable,
    check_variable,
    check_variables,
    slot_save,
    slot_load,
    slot_erase,
    set_connect_serial_dialog,
    show_serial_dialog,
    inventory_get,
    inventory_drop,
    check_inventory,
    set_map_look_script,
    set_entity_look_script,
    set_teleport_enabled,
    check_map,
    set_ble_flag,
    check_ble_flag,
};

enum <uchar>  dialog_screen_alignment_type{
    bottom_left,
    bottom_right,
    top_left,
    top_right,
    bottom_left_with_name,
    bottom_right_with_name,
    top_left_with_name,
    top_right_with_name,
};

enum  <uchar> dialog_response_type{
   no_response,
   select_from_short_list,
   select_from_long_list,
   enter_number,
   enter_alphanumeric,
};

enum  <uchar> serial_response_type{
    response_none,
    response_enter_number,
    response_enter_string,
};

typedef struct
{
    uint32 count;
    uint32 offsets[count];
    uint32 lengths[count];
} MageHeader <read=(count)>;

typedef struct
{
  char name[12];
  uint16 mapLocalScriptId;
  uint16 padding;
} GoDirection <read=(name)>;

local int i;

typedef struct
{
    uchar glitched: 1;
    uchar debug: 1;
    uchar flipX: 1;
    uchar flipY: 1;
    uchar flipDiag: 1;
} RenderFlags <read=Str("g: %d d: %d, fx: %d, fy: %d fd: %d", glitched, debug, flipX, flipY, flipDiag)>;

struct EntityRenderFlags
{
    uchar glitched: 1;
    uchar debug: 1;
    uchar direction:2;
};


typedef struct {
      uint16  x;
      uint16  y;
} EntityPoint <read=Str("%d, %d", x, y)>;

typedef struct {
      char name[12];
      EntityPoint position;
      uint16  on_interact_script_id;
      uint16  on_tick_script_id;
      uint16  primary_id;
      uint16  secondary_id;
      primary_id_type  primaryIdType;
      uchar  current_animation;
      uchar  current_frame;
      union { 
        RenderFlags renderFlags;
        EntityRenderFlags entityRenderFlags;
    }flags <read=(entityRenderFlags.direction)>;
      uchar  hackable_state_a;
      uchar  hackable_state_b;
      uchar  hackable_state_c;
      uchar  hackable_state_d;
} entity <read=(name)>;

typedef struct 
{
    uint16 tileId;
    uchar tilesetId;
    RenderFlags flags;
} MapTile<read=Str("tileset %d [%d] %s",tilesetId, tileId, Str("flip [x, y, diag]: [%d, %d, %d]", flags.flipX, flags.flipY, flags.flipDiag))>;

typedef struct 
{
    char name[16];
    uint16 image_id;
    uint16 image_width;
    uint16 image_height;
    uint16 tile_width;
    uint16 tile_height;
    uint16 cols;
    uint16 rows;
    uint16 padding;
    uint16 tile_global_geometry_ids[cols * rows];
    if ((rows*cols) % 2) {
        uint16 tileset_footer_padding<hidden=true>;
    }
} TileSet <read=(name)>;

typedef struct {
    uint16 tileset_id;
    uint16 frame_count;

    struct animation_frame
    {
        uint16 tile_id;
        uint16 duration;
    } animation_frames[frame_count];
} AnimationData;

typedef struct
{
    char name[16];
    uint16 tileWidth;
    uint16 tileHeight;
    uint16 cols;
    uint16 rows;
    uint16 onLoad;
    uint16 onTick;
    uint16 onLook;
    uchar layerCount;
    uchar playerEntityIndex;
    uint16 entityCount;
    uint16 geometryCount;
    uint16 scriptCount;
    uchar goDirectionCount;

    FSkip(1);

    uint16 entityGlobalIds[entityCount];
    if (geometryCount > 0) {
        uint16 geometryGlobalIds[geometryCount];
    }
    uint16 scriptGlobalIds[scriptCount];
    if (goDirectionCount > 0) {
        GoDirection goDirections[goDirectionCount];
    }
    if ((entityCount + geometryCount + scriptCount) % 2) { FSkip(2); }
    struct {
        MapTile tiles[rows*cols];
    } layers[layerCount]<optimize=false>;
//    uchar filteredEntityCountOnThisMap;


}  MageMap <read=(name)>;

typedef struct {
    uint16 type_id;
    uchar type;
    uchar render_flags;
} entity_type_animation_direction;

typedef struct{
    char name[32];
    uchar padding_a;
    uchar padding_b;
    uchar portrait_index;
    uchar animation_count;
    struct entity_type_animation {
        entity_type_animation_direction north, south, east, west;
    } entity_type_animations[animation_count] <optimize=true>;
} entity_type < read=(name) >;

enum <uchar> geometry_type {
    point,
    polyline,
    polygon
};

typedef struct {
    uint16 x;
    uint16 y;
} Point <read=Str("%d, %d", x,y)>;
    
typedef struct {
    char name[32];
    geometry_type geometryType;
    uchar point_count;
    uchar segment_count;
    uchar padding;
    float path_length;
    if (point_count > 0) {
        Point points[point_count];
    }
    if (segment_count > 0) {
        float segment_lengths[segment_count];
    }
} geometry <read=(name)>;

typedef struct {
    action_type type;
    uchar args[7];
} action;

typedef struct {
    char name[32];
    uint32 action_count;
    if (action_count) {
        action actions[action_count] <read=Str("%s(%d, %d, %d)", EnumToString(type), args[0], args[1], args[2])>;
    }
} script <read=(name)>;

typedef struct {
    char name[32];
    uchar padding[3];
    uchar emote_count;
    entity_type_animation_direction emotes[emote_count];
} portrait <read=(name)>;

struct dialog_response {
    uint16  string_id;
    uint16  map_local_script_id;
};

struct dialog_screen {
      uint16  name_index;
      uint16  border_tileset_index;
      dialog_screen_alignment_type  alignment;
      uchar  font_index;
      uchar  message_count;
      dialog_response_type  response_type;
      uchar  response_count;
      uchar  entity_id;
      uchar  portrait_id;
      uchar  emote;
    if (message_count) {
        uint16  messages[message_count];
    }
    if (response_count) {
          dialog_response responses [response_count];
    }
    if ((message_count) % 2) {FSkip(2);}
};


typedef struct {
    char name[32];
    uint32 screen_count;
    dialog_screen screens[screen_count] <optimize=false>;
} dialog <read=(name)>;

typedef struct {
    char name[32];
    uint16 string_id;
    serial_response_type response_type;
    uchar response_count;
    if (response_count) {
        dialog_response responses[response_count]<optimize=false>;
    }
} serial_dialog <read=(name)>;

typedef struct {
BigEndian();
    uint16 r: 5;
    uint16 g: 5;
    uint16 a: 1;
    uint16 b: 5;
LittleEndian();
}image_color <read=Str("%2d,%2d,%2d %d", r, g, b, a)>;
  
  typedef struct {
    char name[32];
    uchar  color_count;
    uchar  padding;

    image_color colors[color_count];
    if ((color_count + 1) % 2) {FSkip(2);}
} image_color_palette < read=(name) >;

typedef struct (uint16 length) {
    uchar pixels[length];
} image;

    char MagicString[8]; //MAGEGAME
    uint32 EngineVersion;
    uint32 ScenarioDataCRC32;
    uint32 ScenarioDataLength;

    struct {
        MageHeader Map;
        MageHeader Tileset;
        MageHeader Animation;
        MageHeader EntityType;
        MageHeader Entity;
        MageHeader Geometry;
        MageHeader Script;
        MageHeader Portrait;
        MageHeader Dialog;
        MageHeader SerialDialog;
        MageHeader ColorPalette;
        MageHeader String;
        MageHeader SaveFlag;
        MageHeader Variable;
        MageHeader Image;
    } headers;

    struct {
        for (i = 0; i < headers.Map.count; i++) {
            FSeek(headers.Map.offsets[i]);
            MageMap map();
        }
    } maps;

    struct {
        for (i = 0; i < headers.Tileset.count; i++) {
            FSeek(headers.Tileset.offsets[i]);
            TileSet tileset();
        }
    } tilesets;

    struct {
        for (i = 0; i < headers.Animation.count; i++) {
            FSeek(headers.Animation.offsets[i]);
            AnimationData animation();
        }
    } animations;
    
    struct {
        for (i = 0; i < headers.EntityType.count; i++) {
            FSeek(headers.EntityType.offsets[i]);
            entity_type entityType();
        }
    } entityTypes;

    struct {
        for (i = 0; i < headers.Entity.count; i++) {
            FSeek(headers.Entity.offsets[i]);
            entity e() <name="entity">;
        }
    } entities;

    struct {
        for (i = 0; i < headers.Geometry.count; i++) {
            FSeek(headers.Geometry.offsets[i]);
            geometry g() <name="geometry">;
        }
    } geometries;

    struct {
        for (i = 0; i < headers.Script.count; i++) {
            FSeek(headers.Script.offsets[i]);
            script s() <name="script">;
        }
    } scripts;

    struct {
        for (i = 0; i < headers.Portrait.count; i++) {
            FSeek(headers.Portrait.offsets[i]);
            portrait p() <name="portrait">;
        }
    } portraits;

    struct {
        for (i = 0; i < headers.Dialog.count; i++) {
            FSeek(headers.Dialog.offsets[i]);
            dialog d() <name="dialog">;
        }
    } dialogs;

    struct {
        for (i = 0; i < headers.SerialDialog.count; i++) {
            FSeek(headers.SerialDialog.offsets[i]);
            serial_dialog serialDialog();
        }
    } serialDialogs;

    struct {
        for (i = 0; i < headers.ColorPalette.count; i++) {
            FSeek(headers.ColorPalette.offsets[i]);
            image_color_palette colorPalette();
        }
    } colorPalettes;

    struct {
        for (i = 0; i < headers.String.count; i++) {
            FSeek(headers.String.offsets[i]);
            struct{string value();} stringVal<read=(value)>;
        }
    } strings;

    struct {
        for (i = 0; i < headers.SaveFlag.count; i++) {
            FSeek(headers.SaveFlag.offsets[i]);
            struct{string value();} saveFlag<read=(value)>;
        }
    } saveFlags;

    struct {
        for (i = 0; i < headers.Variable.count; i++) {
            FSeek(headers.Variable.offsets[i]);
            struct{string value();} variable<read=(value)>;
        }
    } variables;

    struct {
        for (i = 0; i < headers.Image.count; i++) {
            FSeek(headers.Image.offsets[i]);
            image img(headers.Image.lengths[i]/2) <name="image">;
        }
    } images;
